--------------- binary tree 分类 -------------------
binary tree -- 二叉树
full binary tree - 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。A n depth full binary tree has 2^n - 1 nodes.
complete binary ree - 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
                      若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。
full binary tree is complete bianry tree.

binary search tree - a tree which each node in tree has a value and：
              1. If its left subtree is not empty, the values of all nodes on the left subtree are less than the value of its root node;
              2. If its right subtree is not empty, the values of all nodes on the right subtree are greater than the value of its root node;
              3. Its left and right subtrees are also binary sorted trees
              
balanced binary search tree - 二叉搜索树的变种，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树.

在编程语言中，有些容器是通过二叉树实现的，比如 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn。
熟悉操作语言容器的底层实现也是面试考试的重点。

---------------- 二叉树存储方式 --------------------
链式存储(linked storage)，很好理解, 存储逻辑和链表相同，对于一个vertex，创造一个node，node包含左指针和右指针。
顺序存储（Sequential storage structure）， 这个用array实现，如果父节点的数组下标是 i，那么它的左子节点就是 i * 2 + 1，右子节点就是 i * 2 + 2

---------------- 二叉树 traverse -------------------
二叉树的遍历方式有两种 BFS aand DFS：
DFS 为深度优先搜索（Depth-First Search），在此方式上，分别有三种策略：
前序遍历 Preorder traversal
中序遍历 Inorder traversal
后序遍历 Postorder traversal
区别三种策略的方式是理解,pre, in , post指代对象，这里指代的是中间节点：
pre: 中左右
in: 左中右
post: 左右中
BFS 为广度优先搜索（breadth- first search）, 只有一种遍历方式：层次遍历（迭代法）。

最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

这里其实我们又了解了栈与队列的一个应用场景了。
----------------define a binary tree in language ---------------
这里我用java:

public class TreeNode {
    int val;
  	TreeNode left;
  	TreeNode right;
  	TreeNode() {}
  	TreeNode(int val) { this.val = val; }
  	TreeNode(int val, TreeNode left, TreeNode right) {
    		this.val = val;
    		this.left = left;
    		this.right = right;
  	}
}
